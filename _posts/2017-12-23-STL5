---
layout: post
title: "右值引用与模板"
data: 2017-12-23
description: "右值引用与模板"
tag: STL
---

### 左值右值 ###
在c/c++程序中，所有数据的外在形式无非是两种，其一：变量；其二：由变量组成的表达式。假设把这两种数据类型全部看成是表达式，则他们可以被分为两种类型：左值（出现在表达式的左边）和右值（出现在表达式的右边）。
左值和右值由什么区别呢？一个典型的代表就是，i++和++i。

 1. i++返回原来的值，++i返回+1后的值
 2. i++不能作为左值，而++i可以
 
一般来说，左值是可以放到赋值符号的左边的变量，但能否被赋值不是区分左值和右值的关键。如c++的const左值是不能被赋值的，而作为临时对象的右值可能允许被赋值。左值和右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。

> 左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值得表达式的值（以上引用自中文维基百科）
> 
 - 能否用“取地址&”运算符获得对象的内存地址。
 - 对于临时对象，它可以存储于寄存器中，所以是没办法用“取地址&”运算符；
 - 对于常量，它可能被编码到机器指令的“立即数”中，所以是没办法用“取地址&”运算符；（以上引用自知乎）


----------


    int i = 0;
    int *p1 = &(++i);    //正确
    int *p2 = &(i++);    //错误
    
    ++i = 1;            //正确
    i++ = 5;            //错误
    


----------
为什么i++不能作为左值，而++i可以呢？我们具体看一下他们的实现


----------

    //前缀形式
    int& int::operator++() //这里返回的是一个引用
    {
        //函数本身无参，意味着是在自身空间内加1的
        *this += 1;
        return *this;
    }
    
    //后缀形式
    const int int::operator++(int) //函数返回值是非左值得，是与前缀形式的差别所在
    {
        //函数带参，说明有另外的空间开辟
        int oldValue = *this; //取回值
        ++(*this);
        return oldValue; //返回被取回的值
    }


----------
正如上述代码所见，i++返回的是一个临时变量，而临时变量是右值。
综上所述，左值代表一块存储空间，可以保存和接收数据，而右值仅能代表数据。

## 右值引用 ##
在C++11之前，左值可以定义两种引用，定义格式如下：

> T& 别名 = lvalue;  //引用
const T& 别名 = lvalue;   //常引用

对于右值，C++11仅定义一种常引用

> const T& 别名 = rvlaue;
右值仅能代表数据和与其生命周期与其所在语句相同的临时对象，程序语句一结束，临时对象立即被销毁。而以常量的形式强行为右值命名一个变量名，目的就是为了延长右值的生命周期，从而使程序充分利用右值的资源以完成更多的功能。遗憾的是，它是常量，不能满足程序的更多需求。


----------


    #include<iostream>
    using namespace std;

    int main()
    {
        int a = 100;
        int & b = a; //左值a的别名
        const int & c = a; //左值a的常量别名
        const int & d = 100; //右值100的常量别名
        cout<<"a="<<a<<" b="<<b<<" c="<<c<<" d="<<d<<endl;
        int x = 150, y = 250;
        const int & i = x + y;
        cout<<"i="<<i<<endl;
        // i+=10;     //非法，i是左值得别名，不能取地址运算
        // int & f = 10;  //应加const
        return 0;
    }


----------
运行结果
![][1]

为了能充分利用临时对象，C++11标准推出了一种新的数据类型—右值的非常量引用，简称右值引用。定义格式如下：

> T&&　名称 ＝ rvalue


----------

    #include<iostream>
    using namespace std;

    int main()
    {
        int&& a = 100;
        int b = 200;
        int&& c = a + b;
        int&& d = 100;
        a += 10;
        int e = a;
        cout<<"a="<<a<<" b="<<b<<" c="<<c<<" d="<<d<<" e="<<e<<endl;
        return 0;
    }


----------
运行结果
![][2]

从以上代码可以看出，经过右值引用后，右值就变成一个与左值完全相同的持久化对象，引用定义式中的名称就是这个普通对象的名称。

### 右值的应用 ###
## 应用一：转移语义 ##
右值是一种新的数据类型，这就意味着可以利用函数重载技术使得某种函数多实现一种功能。所以，右值引用的第一个应用就是类的拷贝构造函数和赋值运算符的重载。因为使用右值引用为类重载的这两种函数具有资源控制转移功能，因此称这种函数具有转移语义。

深浅拷贝
--
对象掌控的资源：类对象指针成员指向的，由new分配的内存空间。由于这种资源具有稀缺性，使用后对象应该释放它以为其他程序实体所用，故称为资源。
拷贝时出现的问题：析构函数能在对象销毁时及时释放资源，而对拷贝构造函数，指针不是类对象的数据成员，而是真正的数据成员的地址，因此拷贝构造函数不能是仅仅对包括资源指真内在成员的简单复制。由此有深浅拷贝的说法。


----------

    #include<iostream>
    using namespace std;

    class Foo
    {
    public :
        /**
        *构造函数p指向堆中分配的一空间
        */
        Foo(int x)
        {
            p = new int(x);
        }
        /**
        *深拷贝构造函数
        *为新对象申请资源空间
        *将指针指向的数据复制到新对象指针指向的空间
        *复制的是数据,新建指针指向
        */
        Foo(const Foo& r)
        {
            p = new int;
            *p = *(r.p);
        }
        ~Foo()
        {
            if(p != NULL)
            {
                delete p;
            }
        }
        void show_p()
        {
            cout<<p<<" "<<*p<<endl;
        }
    private :
        int *p;
    };
    int main()
    {
        Foo Foo1(50);
        Foo Foo2(Foo1);
        Foo1.show_p();
        Foo2.show_p();
        return 0;
    }
    


----------
运行结果
![][3]
深拷贝的结果是两个程序的数据是相通的，但是结果指针的地址是不一样的，即指针指向不同的资源。
那么对比之下浅拷贝是这样的：


----------

    Foo(const Foo& r)
    {
        p = r.p; //指针指向同一资源
    }
    


----------
浅拷贝是对类成员的简单的赋值，使两个对象的指针存放同一地址，指向同一个资源，即两个对象共享这个资源。销毁对象时，一个存储空间只能被释放一次，当资源已被释放，再次释放时，就会出现问题。
![深浅拷贝示意图][4]

浅拷贝的优点：浅拷贝的拷贝方法相当于是共享的，既不需要在目标对象中为资源分配空间，也不用在两个对象之间复制庞大的资源数据，所以它是又快又节省内存的。
浅拷贝问题的一个解决：如果说有办法将原对象指针置空，那么结果就是元对象把资源控制的权限交给了目标对象。C++11的说法就是实现了资源控制权的转移。显然，这种做法特别适合源对象为临时对象（右值）场合。
因函数以值传递方式处理返回值的过程中需要创建临时对象，因此为类设计这种具有“转移语义”的拷贝构造函数就成了必须。对于上例，具有转移语义的拷贝构造函数如下：


----------

    Foo(Foo&& r)
    {
        p = r.p;     //简单的拷贝使得p和r.p指向同一空间
        //将r.p设置为空指针，源对象放弃资源的控制权
        //这里的nullptr是C++11的新的关键字，等同于NULL
        r.p = nullptr;
    }
    


----------
![转移语句][5]


  [1]: /images/posts/STL5/result.png
  [2]: /images/posts/STL5/result２.png
  [3]: /images/posts/STL5/result3.png
  [4]: /images/posts/STL5/result4.png
  [5]: /images/posts/STL5/result5.png
